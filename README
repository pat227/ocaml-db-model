The purpose of this porject is to provide a convenient manner for devs to
"model" a existing database. Especially usefull if the database has a
large number of tables and fields, this project seeks to provide a fast way
to generate modules and types that match the tables and fields. This spares
the dev from having to manually create modules.

We use cppo? since it already does a good job in a Makefile of replacing
defined constants, but we won't be able to pretty format.

Mapping of data types is described below: 
MYSQL:

NOTE: M is the max display width for int types and unrelated to the range of values a type can contain.
For floating and fixed point types is the maxnumber of digits that can be stored.

Use the uint package in opam that provides Ocaml with unsigned integer types, specifically 8, 16, 32, and 64 unsigned integers.
Since MySQl provides some integer types that don't map perfectly to any type in Ocaml--such as 24 bit medium integers--
it is most wise to never use them--including but not limited to the medium integer mysql data type.

SERIAL alias for BIGINT UNSIGNED NOT NULL ...  -> uint64   (Ocaml-Mysql parses to and from signed Int64?)
BIT -> bool
TINY_INT (8 bit values) -> uint8 when unsigned, else unsupported
BOOL (as alias for TINY_INT) -> bool when a chosen field name prefix, such as is_*, is found
  SMALLINT (16bit values) -> uint16 when unsigned...when signed, unsupported
  MEDIUMINT (24 bit values) -> UNSUPPORTED
| INT (32 bit values) -> 
| INTEGER (32 bit values) -> Core.Std.Int32 when SIGNED, else uint32 when unsigned
BIGINT (64 bit values) -> Core.Std.Int64 when SIGNED, else uint64; NOTE that Mysql
                          only permits values of 63 bits at most--SO USE OCAML's 63 bit integer type.
			  Even UNSIGNED the limit is 63 bits. And mysql converts values to DOUBLE for arithmetic.
DECIMAL  (??? Why does Ocaml-Mysql perform NO conversion?)
   FLOAT
 | DOUBLE -> float

DATE -> Core.Std.Date

   DATETIME
 | TIMESTAMP -> Core.Std.Time

TIME -> Core.Std.Time.Span??? UNSUPPORTED
YEAR -> UNSUPPORTED


VARCHAR (variable length 0 - 65,535 stings) -> string (the only thing that could go wrong is the length of your string exceeds field width.
CHAR[M] where 0<=M<=255 -> string but again, easy to exceed the length
BLOB


FIELD_TYPE_DECIMAL     , Val_long(DECIMAL_TY)},
    {FIELD_TYPE_TINY        , Val_long(INT_TY)},
    {FIELD_TYPE_SHORT       , Val_long(INT_TY)},
    {FIELD_TYPE_LONG        , Val_long(INT_TY)},
    {FIELD_TYPE_FLOAT       , Val_long(FLOAT_TY)},
    {FIELD_TYPE_DOUBLE      , Val_long(FLOAT_TY)},
    {FIELD_TYPE_NULL        , Val_long(STRING_TY)},
    {FIELD_TYPE_TIMESTAMP   , Val_long(TIMESTAMP_TY)},
    {FIELD_TYPE_LONGLONG    , Val_long(INT64_TY)},
    {FIELD_TYPE_INT24       , Val_long(INT_TY)},
    {FIELD_TYPE_DATE        , Val_long(DATE_TY)},
    {FIELD_TYPE_TIME        , Val_long(TIME_TY)},
    {FIELD_TYPE_DATETIME    , Val_long(DATETIME_TY)},
    {FIELD_TYPE_YEAR        , Val_long(YEAR_TY)},
    {FIELD_TYPE_NEWDATE     , Val_long(UNKNOWN_TY)},
    {FIELD_TYPE_ENUM        , Val_long(ENUM_TY)},
    {FIELD_TYPE_SET         , Val_long(SET_TY)},
    {FIELD_TYPE_TINY_BLOB   , Val_long(BLOB_TY)},
    {FIELD_TYPE_MEDIUM_BLOB , Val_long(BLOB_TY)},
    {FIELD_TYPE_LONG_BLOB   , Val_long(BLOB_TY)},
    {FIELD_TYPE_BLOB        , Val_long(BLOB_TY)},
    {FIELD_TYPE_VAR_STRING  , Val_long(STRING_TY)},
    {FIELD_TYPE_STRING      , Val_long(STRING_TY)},
    {-1 /*default*/         , Val_long(UNKNOWN_TY)}
  };



POSTGRES:

